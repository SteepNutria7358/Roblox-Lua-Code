--!nonstrict
local rigModule = require(script.Parent.RigModule)
local tweenService = game:GetService("TweenService")
local module = {

}
module.__index=module
function module.new():GuiAnimation --Creates and returns a new instance of an animation object.
	local animation = { --A table that defines the animation's behavior and state
		KeyFrames=CreateTimeLine(), --The timeline of the animation
		FPS=30, --Frames per second.
		CurrentTime=0, --Current time of the animation.
		TotalFrames=120, --Number of frames in the animation.
		Loops=false, --A flag indicating whether the animation should loop.
		Playing=nil, --State of the animation's playback.
	}
	animation.TimeChanged={ --An event system to notify when the time in the animation changes
		ConnectedFunctions={} --Adds a new function to ConnectedFunctions and returns an object with a Disconnect method.
	}
	function animation.TimeChanged:Connect(func) --Allows you to connect a function to the TimeChanged event.
		table.insert(self.ConnectedFunctions,func) --Adds the function func to the ConnectedFunctions table.
		return {
			Disconnect=function() 
				table.remove(self.ConnectedFunctions,table.find(self.ConnectedFunctions,func)) --Removes the function from the ConnectedFunctions table.
			end
		}
	end
	function animation.TimeChanged:Fire(input) --Used to trigger the TimeChanged event, which calls all connected listener functions.
		for _,func in pairs(self.ConnectedFunctions) do --Iterates over all the connected functions.
			func(input) --Each function func is called with the input argument
		end
	end
	animation.Ended={ --Creates an Ended event within the animation object.
		ConnectedFunctions={}
	}
	function animation.Ended:Connect(func) --This method is used to subscribe a function (func) to the Ended event.
		table.insert(self.ConnectedFunctions,func)
		return {
			Disconnect=function()
				table.remove(self.ConnectedFunctions,table.find(self.ConnectedFunctions,func)) --Removes the function from the ConnectedFunctions table.
			end
		}
	end
	function animation.Ended:Fire(input) --This function is defined on the Ended event, which is an event tied to the animation.
		for _,func in pairs(self.ConnectedFunctions) do --This iterates over all the functions stored in self.ConnectedFunctions
			func(input) --The input is passed to the function when the event is fired
		end
	end
	setmetatable(animation,module) --This allows the animation table to use or inherit functions and properties from the module.
	return animation --This returns the animation object (the table) from the function.
end
function module.CreateKeyFrame(Transform:UDim2,TransformAngle:number,EasingStyle:Enum.EasingStyle?,EasingDirection:Enum.EasingDirection?) --Creates a keyframe for an animation, encapsulating an object's position, size, rotation, and easing behavior at a specific point in time.

	local keyframe = {
		Name="KeyFrame", --The name of the keyframe.
		Transform=Transform or UDim2.new(), --Defaults to UDim2.new().
		TransformAngle=TransformAngle or 0, --Defaults to 0, meaning no rotation.
		EasingStyle=EasingStyle or Enum.EasingStyle.Linear , --Defaults to Enum.EasingStyle.Linear, so the animation progresses at a constant speed.
		EasingDirection=EasingDirection or Enum.EasingDirection.In --If no EasingDirection is provided, this defaults to In.
	}
	return keyframe
end
function module.Export(self:GuiAnimation,name:string,parent:Instance) --Creates an Animation folder to hold animation data.
	local animationFolder = Instance.new("Animation",parent) --A new Animation instance is created and parented to the parent instance.
	if name then animationFolder.Name = name end
	animationFolder:SetAttribute("FPS",self.FPS) --Frames per second (from the GuiAnimation object).
	animationFolder:SetAttribute("TotalFrames",self.TotalFrames) --The total number of frames in the animation.
	animationFolder:SetAttribute("Loops",self.Loops) --Whether the animation should loop (Boolean).
	for limb,keyFrames in pairs(self.KeyFrames) do --Tterates through each limb in the animation (self.KeyFrames).
		local jointFolder = Instance.new("Folder",animationFolder) --A new Folder is created and named after the limb and this folder is parented to the animationFolder.
		jointFolder.Name = limb 
		for frameNum,keyFrame:KeyFrame in pairs(keyFrames) do --Iterates through each keyFrame of the limb.
			local frameInstance = Instance.new("IntValue",jointFolder) --
			frameInstance.Name=keyFrame.Name --The frameNum is used as the Value for the IntValue instance.
			frameInstance.Value=tonumber(frameNum) --
			frameInstance:SetAttribute("Transform",keyFrame.Transform) --The position/size of the object at the keyframe (as UDim2).
			frameInstance:SetAttribute("TransformAngle",keyFrame.TransformAngle) --The rotation angle of the object at the keyframe.
			frameInstance:SetAttribute("EasingStyle",keyFrame.EasingStyle.Value) --The easing style used in the animation (e.g., linear, sine).
			frameInstance:SetAttribute("EasingDirection",keyFrame.EasingDirection.Value) --The easing direction.
		end 
	end
	return animationFolder
end
function module:Import(animationInstance:Folder) --A Folder instance that contains the animation data.
	local animation = module.new() --A new GuiAnimation object is created using the module.new() function
	animation.FPS= animationInstance:GetAttribute("FPS") --The function reads the attributes (FPS, TotalFrames, and Loops)
	animation.TotalFrames= animationInstance:GetAttribute("TotalFrames") --from the animationInstance folder
	animation.Loops= animationInstance:GetAttribute("Loops") --and sets them in the animation object.
	for _,jointFrames in pairs(animationInstance:GetChildren()) do --The function then loops through each child in the animationInstance folder.
		animation.KeyFrames[jointFrames.Name]={} --It creates an empty table in animation.KeyFrames to store the keyframes for that joint.
		for _,KeyFrameData in pairs(jointFrames:GetChildren()) do --For each joint, the function loops through the keyframe data stored in the joint folder.
			local keyFrame = module.CreateKeyFrame( --It creates a keyFrame object by calling the module.CreateKeyFrame() function.
				KeyFrameData:GetAttribute("Transform"), --The position/size data for the keyframe.
				KeyFrameData:GetAttribute("TransformAngle"), --The rotation angle of the keyframe..
				Enum.EasingStyle:GetEnumItems()[KeyFrameData:GetAttribute("EasingStyle")+1], --The easing style.
				Enum.EasingDirection:GetEnumItems()[KeyFrameData:GetAttribute("EasingDirection")+1] --The easing direction.
			)
			animation.KeyFrames[jointFrames.Name][KeyFrameData.Value]=keyFrame --The newly created keyFrame is stored in the KeyFrames table under the joint's name.
		end
	end
	return animation --The function then returns the animation object.
end
function CreateTimeLine() --A function that creates a TimeLine object.
	local KeyFrames:{[string]:TimeStamps}={} --The keys are strings. The values are TimeStamps.
	return KeyFrames --The function then returns this empty KeyFrames table.
end
function module.RoundTimeToFrame(self:GuiAnimation, Time)
	return math.round(Time*self.FPS)+1,Time*self.FPS+1
end
function module.FrameToTime(self:GuiAnimation, FrameNum)
	return (FrameNum-1)/self.FPS
end
function module.GetFrame(self:GuiAnimation,Time)
	local frame={}
	for limb,timeStamps in pairs(self.KeyFrames) do

		frame[limb]=self:GetTransformAtTime(limb,Time)

	end
	return frame
end
function module.GetCurrentFrame(self:GuiAnimation)
	return self:GetFrame(self.CurrentTime)
end
function module.GetCurrentFrameNum(self:GuiAnimation)
	return self:RoundTimeToFrame(self.CurrentTime)
end
function module.GetNextTimeStamp(self:GuiAnimation,limb,currentFrame):(KeyFrame?,number?)
	local nextFrameNum,nextTimeStamp=nil,nil
	for frameNum,timeStamp in pairs(self.KeyFrames[limb]) do
		if tonumber(frameNum) > tonumber(currentFrame) and (not nextFrameNum or tonumber(nextFrameNum)>tonumber(frameNum)) then
			nextFrameNum,nextTimeStamp=frameNum, timeStamp
		end
	end
	return nextTimeStamp,nextFrameNum
end
function module.GetPrevTimeStamp(self:GuiAnimation,limb,currentFrame):(KeyFrame?,number?)
	local lastFrameNum,lastTimeStamp=nil,nil
	for frameNum,timeStamp in pairs(self.KeyFrames[limb]) do
		if tonumber(frameNum) < tonumber(currentFrame) and (not lastFrameNum or tonumber(lastFrameNum)<tonumber(frameNum)) then
			lastFrameNum, lastTimeStamp=frameNum, timeStamp
		end

	end
	return lastTimeStamp,lastFrameNum
end
function module.DeleteKeyFrames(self:GuiAnimation,frames:{[string]:{number}})
	for limb,frames in pairs(frames) do
		for _,frameNum in pairs(frames) do
			self.KeyFrames[limb][frameNum]=nil
		end
	end
end
function module.CreateKeyFrameAtFrame(self:GuiAnimation,limb:string,frame:number)
	if not self.KeyFrames[limb] then
		self.KeyFrames[limb]={}
	end
	if self.KeyFrames[limb][frame] then
		return self.KeyFrames[limb][frame]
	end
	local transformData = self:GetTransformAtTime(limb,self:FrameToTime(frame))

	local keyFrame = module.CreateKeyFrame(transformData.Transform,transformData.TransformAngle)
	self.KeyFrames[limb][frame]=keyFrame
	return keyFrame
end
function module.UpdateKeyFrame(self:GuiAnimation,data:{[string]:KeyFrame},frame:number)

	for limb,keyframeOverwrite in pairs(data) do
		local keyframe = self:CreateKeyFrameAtFrame(limb,frame)
		for prop,val in pairs(keyframeOverwrite)  do
			keyframe[prop]=val
		end
	end
end
function module.UpdateKeyFrames(self:GuiAnimation,data:{[number]:{[string]:KeyFrame}})
	for frame,keyFrame in pairs(data) do
		self:UpdateKeyFrame(keyFrame,frame)
	end
end
function module.UpdateCurrentKeyFrame(self:GuiAnimation,data:{[string]:KeyFrame})
	self:UpdateKeyFrame(data, self:GetCurrentFrameNum())
end
function module.GetTransformAtTime(self:GuiAnimation,limb,Time)
	if not self.KeyFrames[limb] then return end
	local frameNum,frameTime = self:RoundTimeToFrame(Time)
	if tonumber(frameNum) == tonumber(frameTime) then
		local keyFrame = self.KeyFrames[limb][frameNum]
		if keyFrame then return keyFrame end
	end
	local prevFrame,prevFrameNum = self:GetPrevTimeStamp(limb,frameTime)
	local nextFrame,nextFrameNum=self:GetNextTimeStamp(limb,frameTime)
	if prevFrame and nextFrame then
		local alpha = tweenService:GetValue((frameTime-prevFrameNum)/(nextFrameNum-prevFrameNum),
			prevFrame.EasingStyle or Enum.EasingStyle.Linear ,
			prevFrame.EasingDirection or Enum.EasingDirection.In
		)
		return {
			Transform = prevFrame.Transform:Lerp(nextFrame.Transform,alpha),
			TransformAngle =prevFrame.TransformAngle+(nextFrame.TransformAngle-prevFrame.TransformAngle)*alpha 
		}
	elseif prevFrame then
		return {
			Transform = prevFrame.Transform,
			TransformAngle =prevFrame.TransformAngle 
		}
	elseif nextFrame then
		return {
			Transform = nextFrame.Transform,
			TransformAngle =nextFrame.TransformAngle 
		}
	else
		return {
			Transform = UDim2.fromOffset(0,0),
			TransformAngle =0
		}
	end
end
function module.SetRigPoseAtTime(self:GuiAnimation,rig,Time)
	local joints = rigModule:GetRigJoints(rig)
	for _,joint in pairs(joints) do
		local transformInfo = self:GetTransformAtTime(joint.Name,Time)

		if not transformInfo then continue end
		joint:SetAttribute("Transform",transformInfo.Transform)
		joint:SetAttribute("TransformAngle",transformInfo.TransformAngle)
	end
end
function module.SetRigPoseAtCurrentTime(self:GuiAnimation,rig,Time)
	self:SetRigPoseAtTime(rig,self.CurrentTime)
	--print(self.KeyFrames)
end
function module.GetKeyFrames(self:GuiAnimation)
	return self.KeyFrames
end
function module.GetKeyFrame(self:GuiAnimation,limb:string,frame:number)
	return self.KeyFrames[limb] and self.KeyFrames[limb][frame]
end
function module.SetCurrentTime(self:GuiAnimation,Time:number)
	local atEnd = false
	local _,TimeFrame = self:RoundTimeToFrame(Time)
	if TimeFrame>=self.TotalFrames then
		Time=self:FrameToTime(self.TotalFrames)
		atEnd = true
	end
	self.CurrentTime=Time
	self.TimeChanged:Fire(Time)
	return atEnd
end
function module.Play(self:GuiAnimation)
	if self.Playing then return end
	local _,TimeFrame = self:RoundTimeToFrame(self.CurrentTime)
	if TimeFrame>=self.TotalFrames then
		self:SetCurrentTime(0)
	end
	self.Playing = game:GetService("RunService").RenderStepped:Connect(function(deltaTime)
		if self:SetCurrentTime(self.CurrentTime+deltaTime) then
			if self.Loops then
				self:SetCurrentTime(0)
			else
				self:Pause()
				self.Ended:Fire()
			end

		end
	end)
end

function module.Stop(self:GuiAnimation)
	self:Pause()
	self:SetCurrentTime(0)
end
function module.Pause(self:GuiAnimation)
	if self.Playing then
		self.Playing:Disconnect()
		self.Playing = nil
	end
end

function module.LoadRig(self:GuiAnimation,rig)
	local con con=self.TimeChanged:Connect(function()
		self:SetRigPoseAtCurrentTime(rig) 
		rigModule:TransformRigJoints(rig)
	end)
	return con
end

export type KeyFrame=typeof(module.CreateKeyFrame(UDim2.new(),0))
export type TimeLine=typeof(CreateTimeLine())
export type TimeStamps={
	[number]:KeyFrame,
}
export type GuiAnimation=typeof(module.new())


return module
